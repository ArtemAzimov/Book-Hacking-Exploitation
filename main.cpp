#include <iostream>
#include <string>
#include <algorithm>

#include "tinyexpr.h"

using std::string, std::cout, std::endl;

// 1, 3, 4, 6 = 24

class MathExprEnum
{
    int     runCounter;
    string  signs;
    string  operators;
    int* intArray;
    unsigned int intArraySize;
    int value;

public:
    MathExprEnum()      // default constructor
    {
        runCounter = 0;
        intArraySize = 4;
        intArray = new int[intArraySize] {1, 3, 4, 6};
        value = 24;
        signs = ("+-");
        operators = ("-*/");
    }
    ~MathExprEnum(){}

    const char* toChar(string str)
    {
        char chr_array[str.length() + 1];
        const char *pchar = chr_array;
        strcpy(chr_array, str.c_str());
        return pchar;
    }

    string toString(int* array)
    {
        string str;
        for (int i = 0; i < intArraySize; i++) 
        {
            str += std::to_string(array[i]);
        }
        return str;
    }

    void DefaultFiller(string source)       // fill all posible for altering positions with '+'
    {
        unsigned int index = 0;
        int num_of_chars[4] {2, 2, 3, 2};
        int n = 0;

        for (int i : num_of_chars)      
        {
            source.insert(index, num_of_chars[n], '+');
            index += num_of_chars[n] + 1;
            n++;
        }
        SignFiller(source);
    }

    void SignFiller(string source)      // fill with signs '-' from begin to end
    {
        int num_of_chars2[6] {0, 1, 3, 3, 1, 3};
        int n2 = 0;

        for (int index = 0; index < source.length(); index += num_of_chars2[n2])        
        {
            for (int j = 0; j < signs.length(); j++)
            {
                source[index] = signs[1];
                OperatorFiller(source);
            }
            n2++;
        }
    }

    void OperatorFiller(string source)      // fill with operators from begin to end
    {
        int num_of_chars3[3] {3, 3, 4};
        int n3 = 0;
        int index = 3;

        for (index; index <= 10; index += num_of_chars3[n3])        
        {
            for (int j = 0; j < operators.length(); j++)
            {
                source[index] = operators[j];
                BracketPlacer(source);
            }
            n3++;
        }
    }

    void BracketPlacer(string source)
    {
        string case1 = source;
        string case2 = source;
        string case3 = source;
        string case4 = source;

        // case 1 (x+x)+x+x
        case1.insert(1, 1, '(');
        case1.insert(7, 1, ')');
        EvaluationResult(case1);        

        // case 2 x+(x+x)+x
        case2.insert(4, 1, '(');
        case2.insert(11, 1, ')');
        EvaluationResult(case2);

        // case 3 x+x+(x+x)
        case3.insert(8, 1, '(');
        case3.append(")");
        EvaluationResult(case3);

        // case 4 (x+x)+(x+x)
        case4.insert(1, 1, '(');
        case4.insert(7, 1, ')');
        case4.insert(9, 1, '(');
        case4.append(")");
        EvaluationResult(case4);
    }

    void EvaluationResult(string source)
    {
        ShowExpression(source);
        te_parser pars;
        auto result = pars.evaluate(toChar(source));
        if (result == value) cout << "******************* SOLUTION FOUND!!!!" << endl;
    }

    void ArrayPermutations()
    {
        string strArrayPermd;
        string strArray = toString(intArray);
        std::sort(strArray.begin(), strArray.end());
        DefaultFiller(strArray);
        while(std::next_permutation(strArray.begin(), strArray.end()))
        {
            DefaultFiller(strArray);
        }
    }

    void ShowExpression(string str)
    {
        cout << str << endl;
        runCounter++;
    }

    void ShowRunCounter()
    {
        cout << ".............Number of variants: " << runCounter << endl;
    }
};



int main()
{
    MathExprEnum x;
    x.ArrayPermutations();
    x.ShowRunCounter();
}